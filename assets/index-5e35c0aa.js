(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const e of document.querySelectorAll('link[rel="modulepreload"]'))s(e);new MutationObserver(e=>{for(const h of e)if(h.type==="childList")for(const n of h.addedNodes)n.tagName==="LINK"&&n.rel==="modulepreload"&&s(n)}).observe(document,{childList:!0,subtree:!0});function i(e){const h={};return e.integrity&&(h.integrity=e.integrity),e.referrerPolicy&&(h.referrerPolicy=e.referrerPolicy),e.crossOrigin==="use-credentials"?h.credentials="include":e.crossOrigin==="anonymous"?h.credentials="omit":h.credentials="same-origin",h}function s(e){if(e.ep)return;e.ep=!0;const h=i(e);fetch(e.href,h)}})();const w=(a,t,i)=>(t/=i/2,t<1?a/2*Math.pow(t,3):(t-=2,a/2*(Math.pow(t,3)+2))),S=async()=>await(await fetch("./words.json")).json(),m=(a,t)=>Math.floor(Math.random()*(t-a+1))+a,T=a=>a*(Math.PI/180),M=a=>a*(180/Math.PI),u=(a,t="0",i=2)=>a.padStart(i,t);class F{constructor({ctx:t,x:i,y:s,width:e,position:h}){this.ctx=t,this.x=i,this.y=s,this.position=h,this.width=e,this.distanceToCenter={x:0,y:0},this.centerCoordinate=0,this.currentFrame=0,this.step=12,this.text="",this.fontSize=16}get isCenterX(){return this.distanceToCenter.x===this.centerCoordinate}get isCenterY(){return this.distanceToCenter.y===this.centerCoordinate}get isCenter(){return this.isCenterX&&this.isCenterY}draw(){this.drawPlayer(),this.drawText()}drawPlayer(){this.ctx.beginPath(),this.ctx.fillStyle="#ff0000",this.ctx.fillRect(this.position.x,this.position.y,this.width,this.width),this.ctx.closePath()}drawText(){this.ctx.font=`${this.fontSize}px Arial`,this.ctx.fillStyle="#000";const{width:t}=this.ctx.measureText(this.text);this.ctx.fillText(this.text,this.position.x+this.width/2-t/2,this.position.y+this.width/2+this.fontSize/2)}async move({x:t,y:i},s){s&&await this.animateMovement(s),this.x+=t,this.y+=i}async animateMovement(t){await this.animate({x:this.position.x+t.x,y:this.position.y+t.y}),this.distanceToCenter.x+=t.x,this.distanceToCenter.y+=t.y}async animate({x:t,y:i}){const s={x:t-this.position.x,y:i-this.position.y},e={x:this.position.x,y:this.position.y};return new Promise(h=>{const n=()=>{if(this.currentFrame>this.step)return this.currentFrame=0,h();this.position.x=e.x+w(s.x,this.currentFrame,this.step),this.position.y=e.y+w(s.y,this.currentFrame,this.step),this.currentFrame++,requestAnimationFrame(n)};n()})}}const g=1,v=[[0,1],[0,-1],[1,0],[-1,0]],A=[[-1,-1],[1,-1],[-1,1],[1,1]],P=[...v,...A];class z{constructor({ctx:t,x:i,y:s,width:e,value:h,coordinate:n,word:r,isFinishCell:o}){this.ctx=t,this.x=i,this.y=s,this.width=e,this.value=h,this.coordinate=n,this.word=r,this.color=this.value===g?"#ffba00":"#fff3d2",this.currentFrame=0,this.step=12,this.fontSize=16,this.isFinishCell=o,this.finishFlagImage=null,this.isFinishCell&&(this.finishFlagImage=new Image,this.finishFlagImage.src="./assets/finish-flag.png")}draw(){this.drawCell(),this.isFinishCell&&this.drawFinishFlag(),this.word&&this.drawText()}drawFinishFlag(){const t=this.finishFlagImage.width/2,i=this.finishFlagImage.height/2;this.ctx.drawImage(this.finishFlagImage,this.x+this.width/2-t/2,this.y+this.width/2-i/2,t,i)}drawTextBg(t){this.ctx.beginPath(),this.ctx.fillStyle="rgba(0,0,0,0.5)",this.ctx.rect(this.x+this.width/2-t/2-3,this.y+this.width/2-this.fontSize/2,t+3*2,this.fontSize+3),this.ctx.fill(),this.ctx.closePath()}drawText(){this.ctx.font=`${this.fontSize}px Arial`;const t=this.ctx.measureText(this.word);this.drawTextBg(t.width),this.ctx.fillStyle="#fff",this.ctx.fillText(this.word,this.x+this.width/2-t.width/2,this.y+this.width/2+this.fontSize/2)}drawCell(){this.ctx.beginPath(),this.ctx.fillStyle=this.color,this.ctx.strokeStyle="#000",this.ctx.rect(this.x,this.y,this.width,this.width),this.ctx.stroke(),this.ctx.fill(),this.ctx.closePath()}async move({x:t,y:i}){await this.animate({x:this.x+t*this.width,y:this.y+i*this.width})}async animate({x:t,y:i}){const s={x:t-this.x,y:i-this.y},e={x:this.x,y:this.y};return new Promise(h=>{const n=()=>{if(this.currentFrame>this.step)return this.currentFrame=0,h();this.x=e.x+w(s.x,this.currentFrame,this.step),this.y=e.y+w(s.y,this.currentFrame,this.step),this.currentFrame++,requestAnimationFrame(n)};n()})}}class b{constructor({ctx:t,x:i,y:s}){this.ctx=t,this.x=i,this.y=s,this.scale=4,this.imageUrl="./assets/arrow.png",this.image=new Image,this.image.src=this.imageUrl,this.angle=0,this.currentFrame=0,this.step=15}draw(){const t=this.image.width/this.scale,i=this.image.height/this.scale;this.ctx.save(),this.ctx.translate(t/2+this.x,i/2+this.y),this.ctx.rotate(T(this.angle)),this.ctx.drawImage(this.image,-t/2,-i/2,t,i),this.ctx.restore()}animateRotate(t){const i=t-this.angle,s=this.angle;return new Promise(e=>{const h=()=>{if(this.currentFrame>this.step)return this.currentFrame=0,e();this.angle=s+w(i,this.currentFrame,this.step),this.currentFrame++,requestAnimationFrame(h)};h()})}}class I{constructor({canvas:t}){this.canvas=t,this.ctx=t.getContext("2d"),this.path=0,this.maps=[[1,1,1,0,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,0,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,0,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,0,1,1,1,1,1,1,1,0,0,0,0],[1,0,0,0,1,0,0,0,0,0,0,0,1,1,0],[1,0,1,0,0,0,1,0,1,1,1,0,1,1,1],[1,0,1,1,1,0,0,0,0,1,1,0,1,1,1],[0,0,0,1,1,0,1,1,0,0,1,0,1,1,1],[1,1,0,1,1,0,1,1,1,0,1,0,0,0,1],[1,1,0,0,0,0,1,1,1,0,0,0,1,0,1],[1,1,0,1,1,1,1,1,1,1,1,1,1,0,1]],this.cells=[],this.extenderCells=[],this.cellSize=100,this.cellPadding=5,this.viewBox={x:0,y:0,width:this.canvas.width,height:this.canvas.height},this.playerInitialPosition={x:Math.floor(this.maps[0].length/2),y:Math.floor(this.maps.length/2)},this.player=null,this.isAnimating=!1,this.overflowedView={x:0,y:0},this.wordsMap=Array.from({length:this.maps.length},()=>Array(this.maps[0].length).fill(null)),this.availableWords=[],this.currentTypingValue="",this.arrow=null,this.finishCoordinate={x:this.playerInitialPosition.x+3,y:this.playerInitialPosition.y-1},this.start=null,this.timer=null,this.timerInterval=null,this.isDevMode=!0}async init(){console.log("init");const{x:t,y:i}=this.playerInitialPosition;this.player=new F({ctx:this.ctx,x:t,y:i,position:this.centerPoint,width:this.cellSize}),this.arrow=new b({ctx:this.ctx,x:this.canvas.width-100,y:this.canvas.height-100}),this.availableWords=await S(),this.initFinishFlag(),this.initWordsMap(),this.initTimer(),this.setViewBox(),this.listener(),this.render(),this.calculateArrowAngle()}initFinishFlag(){let t,i,s;do{t=m(0,this.maps.length-1),i=m(0,this.maps[0].length-1);const e=2;s=t>=this.player.y-e&&t<=this.player.y+e||i>=this.player.x-e&&i<=this.player.x+e}while(s||this.maps[t][i]===g);this.finishCoordinate={y:t,x:i}}initTimer(){this.start=Date.now();const t=()=>{const i=Date.now();this.timer=Math.floor((i-this.start)/1e3),this.timerInterval=setTimeout(t,1e3)};t()}initWordsMap(){const t=({x:i,y:s},e)=>{for(const[h,n]of P){const{x:r,y:o}={x:i+h,y:s+n};if(this.isValidCoordinate({x:r,y:o})&&this.wordsMap[o][r]===e)return!0}return!1};for(const[i,s]of this.wordsMap.entries())for(const[e,h]of s.entries()){if(this.maps[i][e]===g)continue;let n;do n=this.availableWords[m(0,this.availableWords.length-1)];while(t({x:e,y:i},n));this.wordsMap[i][e]=n}}setViewBox(){const t=(this.canvas.width-this.cellSize)/2,i=(this.canvas.height-this.cellSize)/2;this.viewBox.x=t,this.viewBox.y=i,this.initViewBoxMap()}needChangePlayerPosition({x:t,y:i}){const s=this.player.x+t+this.blockToRender.x*t,e=this.player.y+i+this.blockToRender.y*i,h=s<0||s>this.maps[0].length-1;return(e<0||e>this.maps.length-1)&&i!==0||!this.player.isCenterY&&i!==0||h&&t!==0||!this.player.isCenterX&&t!==0}async handleMapOverflow({axis:t,dir:i,expandCb:s,collapseCb:e}){const h=this.player[t]+i-this.blockToRender[t]<0,n=this.player[t]+i+this.blockToRender[t]>=(t==="y"?this.maps.length:this.maps[0].length),r={x:0,y:0},o=this.overflowedView[t],l=this.getViewBoxRemainder[t],c=i===-1&&h&&!o,x=i===1&&!h&&o<0,d=i===1&&n&&!o,y=i===-1&&!n&&o>0;c||d?(this.overflowedView[t]+=l*i,s(),await this.moveMapOverflow({...r,[t]:this.overflowedView[t]})):(x||y)&&(e(),await Promise.all([this.moveMapOverflow({...r,[t]:this.overflowedView[t]*-1}),this.player.animateMovement({...r,[t]:l*i})]),this.overflowedView[t]=0)}listener(){window.addEventListener("keydown",async t=>{const i=[...Array(26)].map((e,h)=>String.fromCharCode(h+"a".charCodeAt())),s=t.key.toLowerCase();if(i.indexOf(s)!==-1)this.currentTypingValue+=s;else if(s===" ")for(const[e,h]of v){const{x:n,y:r}={x:this.player.x+e,y:this.player.y+h};this.isValidCoordinate({x:n,y:r})&&this.wordsMap[r][n]===this.currentTypingValue&&(this.currentTypingValue="",await this.handlePlayerMovement({x:e,y:h}))}else if(s==="backspace")if(t.ctrlKey)this.currentTypingValue="";else{const e=this.currentTypingValue;this.currentTypingValue=e.substring(0,e.length-1)}if(this.isDevMode){const e={ArrowUp:{x:0,y:-1},ArrowDown:{x:0,y:1},ArrowLeft:{x:-1,y:0},ArrowRight:{x:1,y:0}};if(!Object.keys(e).includes(t.code)||this.isAnimating)return;await this.handlePlayerMovement(e[t.code])}})}async handlePlayerMovement(t){if(this.isAnimating)return;const{x:i,y:s}=t,e=this.needChangePlayerPosition(t);let h=null;e&&(h={x:this.cellSize*i,y:this.cellSize*s}),this.isAnimating=!0;const n=[];n.push(this.handleMapOverflow({axis:"y",dir:s,expandCb:()=>h.y-=this.overflowedView.y,collapseCb:()=>h=null})),n.push(this.handleMapOverflow({axis:"x",dir:i,expandCb:()=>h.x-=this.overflowedView.x,collapseCb:()=>h=null})),n.push(this.player.move(t,h)),e||n.push(this.moveViewBoxMap(t)),await Promise.all(n),this.isAnimating=!1,this.calculateArrowAngle(),this.isGameFinish&&this.finishGame()}calculateArrowAngle(){const{x:t,y:i}=this.finishCoordinate,{x:s,y:e}=this.player,h=Math.atan2(i-e,t-s);let n=M(h);n<0&&(n+=360),this.arrow.animateRotate((n+90)%360)}finishGame(){clearTimeout(this.timerInterval);const{minute:t,second:i}=this.formattedTimer,s=`${u(t.toString())}:${u(i.toString())}`;alert(`Game finish! Time: ${s}`),window.location.reload()}draw(){this.drawMap(),this.player.draw(),this.arrow.draw(),this.drawTimer(),this.player.text=this.currentTypingValue}drawTimer(){const{minute:t,second:i}=this.formattedTimer,s=u(t.toString())+":"+u(i.toString());this.ctx.save(),this.ctx.font="32px Arial";const{width:e}=this.ctx.measureText(s);this.ctx.fillStyle="#000",this.ctx.fillText(s,canvas.width/2-e/2,60),this.ctx.restore()}initViewBoxMap(){const{x:t,y:i}=this.centerPoint,s=this.blockToRender;for(let e=0;e<s.y*2+1;e++){const h=[],n=this.player.y-(s.y-e);for(let r=0;r<s.x*2+1;r++){const o=this.player.x-(s.x-r),l=this.createCell({x:t+(r-s.x)*this.cellSize,y:i+(e-s.y)*this.cellSize,value:this.maps[n][o],coordinate:{x:o,y:n}});h.push(l)}this.cells.push(h)}console.log(this.cells.map(e=>e.map(h=>h.value))),console.log(JSON.parse(JSON.stringify(this.cells)))}async moveViewBoxMap({x:t,y:i}){const s=[],{x:e,y:h}=this.centerPoint,n=this.blockToRender;for(let r=0;r<n.y*2+1;r++){const o=this.player.y+this.blockToRender.y*i;if(i!==0&&!this.extenderCells.length){const l=[];for(let c=0;c<n.x*2+1;c++){const x=this.player.distanceToCenter.x,d=Math.ceil(Math.abs(x/this.cellSize))*Math.sign(x)*-1,y=this.blockToRender.x-c,p=this.player.x+d-y,f=this.createCell({x:e+(c-n.x)*this.cellSize-this.overflowedView.x,y:h+n.y*this.cellSize*i,value:this.maps[o][p],coordinate:{x:p,y:o}});l.push(f)}this.extenderCells.push(l)}for(let l=0;l<n.x*2+1;l++){if(t!==0&&!this.extenderCells.length){const c=[],x=this.player.x+n.x*t;for(let d=0;d<n.y*2+1;d++){const y=this.player.distanceToCenter.y,p=Math.ceil(Math.abs(y/this.cellSize))*Math.sign(y)*-1,f=this.player.y+p-(n.y-d),C=this.createCell({x:e+n.x*t*this.cellSize,y:h+(d-n.y)*this.cellSize-this.overflowedView.y,value:this.maps[f][x],coordinate:{x,y:f}});c.push(C)}this.extenderCells.push(c)}s.push(this.cells[r][l].move({x:t*-1,y:i*-1}))}}if(await Promise.all(s),i!==0)i===1?(this.cells.shift(),this.cells.push(...this.extenderCells)):(this.cells.pop(),this.cells.unshift(...this.extenderCells));else if(t!==0)for(const[r,o]of this.cells.entries())t===1?(o.shift(),o.push(this.extenderCells[0][r])):(o.pop(),o.unshift(this.extenderCells[0][r]));this.extenderCells=[]}async moveMapOverflow({x:t,y:i}){const s=[];for(const e of this.cells)for(const h of e)s.push(h.move({x:t*-1/this.cellSize,y:i*-1/this.cellSize}));await Promise.all(s)}createCell({x:t,y:i,value:s,coordinate:e}){return new z({x:t,y:i,value:s,coordinate:e,ctx:this.ctx,width:this.cellSize,word:this.wordsMap[e.y][e.x],isFinishCell:Object.keys(e).every(h=>e[h]===this.finishCoordinate[h])})}drawMap(){for(const t of this.extenderCells)for(const i of t)i.draw();for(const t of this.cells)for(const i of t)i.draw()}isValidCoordinate({x:t,y:i}){return t>=0&&t<this.maps[0].length&&i>=0&&i<this.maps.length}get isGameFinish(){return Object.keys(this.finishCoordinate).every(t=>this.finishCoordinate[t]===this.player[t])}get formattedTimer(){return{minute:Math.floor(this.timer/60),second:this.timer%60}}get centerPoint(){return{x:this.canvas.width/2-this.cellSize/2,y:this.canvas.height/2-this.cellSize/2}}get blockToRender(){return{x:Math.ceil(this.viewBox.x/this.cellSize),y:Math.ceil(this.viewBox.y/this.cellSize)}}get getViewBoxRemainder(){return{x:this.viewBox.x%this.cellSize?this.cellSize-this.viewBox.x%this.cellSize:0,y:this.viewBox.y%this.cellSize?this.cellSize-this.viewBox.x%this.cellSize:0}}render(){this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height),requestAnimationFrame(this.render.bind(this)),this.draw()}}const V=document.querySelector("#canvas"),O=new I({canvas:V});O.init();
